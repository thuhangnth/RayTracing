<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TH_RayTracing</title>
</head>
<body>
    <script src="http://www.comp.nus.edu.sg/~hugh/CS3211/js/decls.js?nocache"></script>
    <script src="http://www.comp.nus.edu.sg/~hugh/CS3211/js/gpu.js?nocache"></script>
    <div id="fps">1</div>
    <script>
        var camera = [
            0,20,-200,                     // x,y,z coordinates
            0,0,1,                     // Direction vector
            45                         // field of view : example 45
        ];

        var lights = [
            2,                         // number of lights
            200,200,200, 0,1,0,        // light 1, x,y,z location, and rgb colour (green)
            100,100,100, 1,1,1         // light 2, x,y,z location, and rgb colour (white)
        ];

        var objects = [
            3,                                                                             // number of objects
            ObjTyp.SPHERE,      13, 1.0,0.0,0.0,0.2,0.7,0.1,1.0,  0,50,280,40,           // typ,recsz,r,g,b,spec,lamb,amb,opac, x,y,z,rad,
            ObjTyp.SPHERE,      13, 0.0,0.0,1.0,0.2,0.7,0.1,1.0,  120,50,280,10,           // typ,recsz,r,g,b,spec,lamb,amb,opac, x,y,z,rad,
            ObjTyp.CYLINDER,    14, 0.0,1.0,0.0,0.2,0.7,0.1,1.0,  0,100,280,40,10
        ];

        var pi=22/7;
        var width_in_pixel = 800;  //Screen width in pixel unit
        var height_in_pixel = 600; //Screen height in pixel unit
        var ratio = width_in_pixel/height_in_pixel; //Ratio of screen width to screen height
        var camAngleRad=camera[6]*pi/180;
        var halfWidth = Math.tan(0.5*camAngleRad);  //screen half width in coordinate unit. ASSUMPTION: focal length = 1
        var halfHeight = halfWidth/ratio;
        var width = halfWidth*2;
        var height = halfHeight*2;
        var pixelWidth = width/width_in_pixel;    //width of a pixel
        var pixelHeight = height/height_in_pixel; //height of a pixel

        var gpu = new GPU();

        function dot(x1,y1,z1,x2,y2,z2)
        {
            return x1*x2 + y1*y2 + z1*z2;
        }

        function getMinRoot(a,b,c,sqrt)
        {
            var x1 = (-b + sqrt)/(2*a);
            var x2 = (-b - sqrt)/(2*a);
            if (x1<=x2)
                return x1;
            else
                return x2;
        }

        function getDiscriminant(a,b,c)
        {
            var discriminant = b*b - 4*a*c;
            if(discriminant <0)
            {
                return -1;
            }
            else
            {
                return Math.sqrt(discriminant);
            }
        }
        function CylinderIntersect(a,b,c,sqrt,unit_y,ymin,ymax)
        {
            var t1 = (-b + sqrt)/(2*a);
            var t2 = (-b - sqrt)/(2*a);
            var temp;
            if (t2<t1) // Make sure t1<t2
            {
                temp = t2;
                t2=t1;
                t1=temp;
            }
            var y1 = t1*unit_y;
            var y2 = t2*unit_y;
            if(y1>=ymin && y1<=ymax)
            {
                return t1;
            }
            else if(y2>=ymin && y2<=ymax)
            {
                return t2;
            }
            else
                return -1;
        }

        gpu.addFunction(dot);
        gpu.addFunction(getMinRoot);
        gpu.addFunction(getDiscriminant);
        gpu.addFunction(CylinderIntersect);

        function doit(mode) {
            var opt = {
                dimensions: [width_in_pixel,height_in_pixel],
                debug: true,
                graphical: true,
                safeTextureReadHack: false,
                constants: { OBJCOUNT: objects[0],
                    EMPTY: ObjTyp.EMPTY,    SPHERE: ObjTyp.SPHERE,   CUBOID: ObjTyp.CUBOID,
                    CYLINDER: ObjTyp.CYLINDER,   CONE: ObjTyp.CONE,   TRIANGLE: ObjTyp.TRIANGLE },
                mode: mode
            };

            var y = gpu.createKernel(function(halfWidth,pixelWidth,halfHeight,pixelHeight,objects,cam) {
                this.color(0.95,0.95,0.95);
                var ray_x= -halfWidth + this.thread.x * pixelWidth + 0.5*pixelWidth; //map pixel to coord
                var ray_y= -halfHeight + this.thread.y * pixelHeight + 0.5*pixelHeight; // map pixel to coords
                var ray_z= 1; // default: focal length = 1
                var length = Math.sqrt(ray_x*ray_x + ray_y*ray_y + ray_z*ray_z);
                var unit_ray_x = ray_x/length;
                var unit_ray_y = ray_y/length;
                var unit_ray_z = ray_z/length;
                var distance = 0;
                var minDist;
                var count = 1;
                var idx = 1;
                var nextidx = 1;
                for (i=0;i<this.constants.OBJCOUNT;i++)
                {
                    var hit = 0;
                    var t;
                    idx = nextidx;
                    nextidx = idx + objects[idx+1];
                    var obj_x = objects[idx + 9]-cam[0];
                    var obj_y = objects[idx + 10]-cam[1];
                    var obj_z = objects[idx + 11]-cam[2];
                    if (objects[idx]== this.constants.SPHERE) {
                        var radius1 = objects[idx+12];
                        var a1=(unit_ray_x*unit_ray_x)+(unit_ray_y*unit_ray_y)+(unit_ray_z*unit_ray_z);
                        var b1=-2*(unit_ray_x*obj_x+unit_ray_y*obj_y+unit_ray_z*obj_z);
                        var c1=(obj_x*obj_x)+(obj_y*obj_y)+(obj_z*obj_z)-(radius1*radius1);
                        var sqrt1 = getDiscriminant(a1,b1,c1);
                        if (sqrt1>=0)
                        {
                            t = getMinRoot(a1,b1,c1,sqrt1);
                        }
                        if(t>0)
                        {
                            hit = 1;
                            distance = t*length;
                        }
                    }
                    else if(objects[idx]== this.constants.CYLINDER)
                    {
                        var radius2 = objects[idx+12];
                        var height = objects[idx+13];
                        var a2 = (unit_ray_x*unit_ray_x)+(unit_ray_z*unit_ray_z);
                        var b2 = -(2*unit_ray_x*obj_x + 2*unit_ray_z*obj_z);
                        var c2 = (obj_x*obj_x)+(obj_z*obj_z)-radius2*radius2;
                        var sqrt2 = getDiscriminant(a2,b2,c2);
                        if (sqrt2>=0)
                        {
                            t= CylinderIntersect(a2,b2,c2,sqrt2,unit_ray_y,obj_y,obj_y+height);
                            if(t>=0) {
                                hit = 1;
                                distance = t * length;
                            }
                        }
                    }
                    if (hit == 1)
                    {
                        if (count == 1) minDist = distance;
                        count++;
                        if (distance <= minDist) {
                            this.color(objects[idx + 2], objects[idx + 3], objects[idx + 4]);
                        }
                    }
                }
            }, opt);
            return y;
        }
        var start_time;
        var end_time;
        start_time = Math.floor(new Date().getTime());
        var mykernel = doit("gpu");
        mykernel(halfWidth,pixelWidth,halfHeight,pixelHeight,objects,camera);
        var canvas = mykernel.getCanvas();
        document.getElementsByTagName('body')[0].appendChild(canvas);
        end_time = Math.floor(new Date().getTime());
        document.write(end_time - start_time);

        var f = document.querySelector("#fps");
        var angle = 0;
        var rotRad = objects[23]-objects[10];
        function renderLoop() {
            f.innerHTML = fps.getFPS();
            mykernel(halfWidth, pixelWidth, halfHeight, pixelHeight, objects, camera);
            var cv = document.getElementsByTagName("canvas")[0];
            var bdy = cv.parentNode;
            var newCanvas = mykernel.getCanvas();
            bdy.replaceChild(newCanvas, cv);
            objects[23] = objects[10]+Math.cos(angle)*rotRad;
            objects[25] = objects[12]+Math.sin(angle)*rotRad;
            angle = angle+0.05;
            requestAnimationFrame(renderLoop);
        }
        window.onload = renderLoop;
    </script>
    <canvas width="800" height="600"></canvas>
</body>
</html>