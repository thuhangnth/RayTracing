<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TH_RayTracing</title>
</head>
<body>
    <script src="http://www.comp.nus.edu.sg/~hugh/CS3211/js/decls.js?nocache"></script>
    <script src="http://www.comp.nus.edu.sg/~hugh/CS3211/js/gpu.js?nocache"></script>
    <input type="button" value="Zoom in" onclick="return change(this);">
    <input type="button" value="Zoom out" onclick="return change(this);">
    <div id="fps">1</div>
    <script>

        var selection = 0;

        function change( el ) {
            if ( el.value === "Zoom in" ) {
                selection = 1;
            } else {
                selection = 2;
            }
        }

        var camera = [
            0,20,-200,                     // x,y,z coordinates
            0,0,1,                     // Direction vector
            45                         // field of view : example 45
        ];

        var lights = [
            1,                         // number of lights
            0,60,50, 0,1,0,        // light 1, x,y,z location, and rgb colour (green)
            //100,100,100, 1,1,1         // light 2, x,y,z location, and rgb colour (white)
        ];

        var objects = [
            10,                                                                             // number of objects
            ObjTyp.SPHERE,      13, 1.0,0.0,0.0,0.2,0.7,0.1,1.0,  0,10,280,40,           // typ,recsz,r,g,b,spec,lamb,amb,opac, x,y,z,rad,
            ObjTyp.SPHERE,      13, 0.0,0.0,1.0,0.2,0.7,0.1,1.0,  120,10,280,10,           // typ,recsz,r,g,b,spec,lamb,amb,opac, x,y,z,rad,
            ObjTyp.CYLINDER,    14, 0.0,1.0,0.0,0.2,0.7,0.1,1.0,  0,70,280,40,10,
            ObjTyp.CYLINDER,    14, 0.0,1.0,0.0,0.2,0.7,0.1,1.0,  120,-50,280,40,10,
            ObjTyp.CYLINDER,    14, 0.5,0.0,0.5,0.2,0.7,0.2,2.0,  -200,-100,380,20,250,
            ObjTyp.CYLINDER,    14, 0.5,0.0,0.5,0.2,0.7,0.2,2.0,  -200,-100,580,20,250,
            ObjTyp.CYLINDER,    14, 0.5,0.0,0.5,0.2,0.7,0.2,2.0,  -200,-100,780,20,250,
            ObjTyp.CYLINDER,    14, 0.5,0.0,0.5,0.2,0.7,0.2,2.0,  200,-100,380,20,250,
            ObjTyp.CYLINDER,    14, 0.5,0.0,0.5,0.2,0.7,0.2,2.0,  200,-100,580,20,250,
            ObjTyp.CYLINDER,    14, 0.5,0.0,0.5,0.2,0.7,0.2,2.0,  200,-100,780,20,250,
            ObjTyp.PLANE,       15, 0.0,0.5,0.5,0.2,0.7,0.2,2.0,  0,-100,0,0,1,0

        ]
        var pi=22/7;
        var width_in_pixel = 1024;  //Screen width in pixel unit
        var height_in_pixel = 768; //Screen height in pixel unit
        var ratio = width_in_pixel/height_in_pixel; //Ratio of screen width to screen height
        var camAngleRad=camera[6]*pi/180;
        var halfWidth = Math.tan(0.5*camAngleRad);  //screen half width in coordinate unit. ASSUMPTION: focal length = 1
        var halfHeight = halfWidth/ratio;
        var width = halfWidth*2;
        var height = halfHeight*2;
        var pixelWidth = width/width_in_pixel;    //width of a pixel
        var pixelHeight = height/height_in_pixel; //height of a pixel

        var gpu = new GPU();

        function dot(x1,y1,z1,x2,y2,z2)
        {
            return x1*x2 + y1*y2 + z1*z2;
        }

        function getMinRoot(a,b,c,sqrt)
        {
            var x1 = (-b + sqrt)/(2*a);
            var x2 = (-b - sqrt)/(2*a);
            if (x1<=x2)
                return x1;
            else
                return x2;
        }

        function getDiscriminant(a,b,c)
        {
            var discriminant = b*b - 4*a*c;
            if(discriminant <0)
            {
                return -1;
            }
            else
            {
                return Math.sqrt(discriminant);
            }
        }
        function CylinderIntersect(a,b,c,sqrt,unit_y,ymin,ymax)
        {
            var t1 = (-b + sqrt)/(2*a);
            var t2 = (-b - sqrt)/(2*a);
            var temp;
            if (t2<t1) // Make sure t1<t2
            {
                temp = t2;
                t2=t1;
                t1=temp;
            }
            var y1 = t1*unit_y;
            var y2 = t2*unit_y;
            if(y1>=ymin && y1<=ymax)
            {
                return t1;
            }
            else if(y2>=ymin && y2<=ymax)
            {
                return t2;
            }
            else
                return -1;
        }

        gpu.addFunction(dot);
        gpu.addFunction(getMinRoot);
        gpu.addFunction(getDiscriminant);
        gpu.addFunction(CylinderIntersect);

        function doit(mode) {
            var opt = {
                dimensions: [width_in_pixel,height_in_pixel],
                debug: true,
                graphical: true,
                safeTextureReadHack: false,
                constants: { OBJCOUNT: objects[0],
                    EMPTY: ObjTyp.EMPTY,    SPHERE: ObjTyp.SPHERE,   CUBOID: ObjTyp.CUBOID,
                    CYLINDER: ObjTyp.CYLINDER,   CONE: ObjTyp.CONE,   TRIANGLE: ObjTyp.TRIANGLE/*,
                    PLANE: ObjTyp.PLANE*/ },
                mode: mode
            };

            var y = gpu.createKernel(function(halfWidth,pixelWidth,halfHeight,pixelHeight,objects,cam, lights) {
                this.color(0.95,0.95,0.95);
                var ray_x= -halfWidth + this.thread.x * pixelWidth + 0.5*pixelWidth; //map pixel to coord
                var ray_y= -halfHeight + this.thread.y * pixelHeight + 0.5*pixelHeight; // map pixel to coords
                var ray_z= 1; // default: focal length = 1
                var length = Math.sqrt(ray_x*ray_x + ray_y*ray_y + ray_z*ray_z);
                var unit_ray_x = ray_x/length;
                var unit_ray_y = ray_y/length;
                var unit_ray_z = ray_z/length;
                var distance = 0;
                var minDist;
                var count = 1;
                var idx = 1;
                var nextidx = 1;
                for (i=0;i<this.constants.OBJCOUNT;i++)
                {
                    var hit = 0;
                    var t;
                    idx = nextidx;
                    nextidx = idx + objects[idx+1];
                    var obj_x = objects[idx + 9]-cam[0];
                    var obj_y = objects[idx + 10]-cam[1];
                    var obj_z = objects[idx + 11]-cam[2];
                    if (objects[idx]== this.constants.SPHERE) {
                        var radius1 = objects[idx+12];
                        var a1=(unit_ray_x*unit_ray_x)+(unit_ray_y*unit_ray_y)+(unit_ray_z*unit_ray_z);
                        var b1=-2*(unit_ray_x*obj_x+unit_ray_y*obj_y+unit_ray_z*obj_z);
                        var c1=(obj_x*obj_x)+(obj_y*obj_y)+(obj_z*obj_z)-(radius1*radius1);
                        var sqrt1 = getDiscriminant(a1,b1,c1);
                        if (sqrt1>=0)
                        {
                            t = getMinRoot(a1,b1,c1,sqrt1);
                        }
                        if(t>0)
                        {
                            hit = 1;
                            distance = t*length;
                        }
                    }
                    else if(objects[idx]== this.constants.CYLINDER)
                    {
                        var radius2 = objects[idx+12];
                        var height = objects[idx+13];
                        var a2 = (unit_ray_x*unit_ray_x)+(unit_ray_z*unit_ray_z);
                        var b2 = -(2*unit_ray_x*obj_x + 2*unit_ray_z*obj_z);
                        var c2 = (obj_x*obj_x)+(obj_z*obj_z)-radius2*radius2;
                        var sqrt2 = getDiscriminant(a2,b2,c2);
                        if (sqrt2>=0)
                        {
                            t= CylinderIntersect(a2,b2,c2,sqrt2,unit_ray_y,obj_y,obj_y+height);
                            if(t>=0) {
                                hit = 1;
                                distance = t * length;
                            }
                        }
                    }
                    /*else if(objects[idx]==this.constants.PLANE)
                    {
                        var nor_x = objects[idx+12];
                        var nor_y = objects[idx+13];
                        var nor_z = objects[idx+14];
                        var length_nor = Math.sqrt(nor_x*nor_x+nor_y*nor_y+nor_z*nor_z);
                        nor_x = nor_x/length_nor;
                        nor_y = nor_y/length_nor;
                        nor_z = nor_z/length_nor;
                        var ND = dot(nor_x,nor_y,nor_z,unit_ray_x,unit_ray_y,unit_ray_z);
                        if (ND!=0)
                        {
                            var NQ = dot(nor_x,nor_y,nor_z,obj_x,obj_y,obj_z);
                            t = NQ/ND;
                            if(t>=0)
                            {
                                hit = 1;
                                distance = t*length;
                            }
                        }
                    }*/
                    if (hit == 1)
                    {
                        var lamb = 1;
                        if (count == 1) minDist = distance;
                        count++;
                        if (distance <= minDist) {
                                var hit_x = unit_ray_x*t;
                                var hit_y = unit_ray_y*t;
                                var hit_z = unit_ray_z*t;
                                var light_x = lights[1]-cam[0] - hit_x;
                                var light_y = lights[2]-cam[1] - hit_y;
                                var light_z = lights[3]-cam[2] - hit_z;
                                var light_length = Math.sqrt(light_x*light_x+light_y*light_y+light_z*light_z);
                                light_x = light_x/light_length;
                                light_y = light_y/light_length;
                                light_z = light_z/light_length;
                                var norm_x = hit_x - obj_x;
                                var norm_y = hit_y - obj_y;
                                var norm_z = hit_z - obj_z;
                                var length_norm = Math.sqrt(norm_x*norm_x+norm_y*norm_y+norm_z*norm_z);
                                norm_x = norm_x/length_norm;
                                norm_y = norm_y/length_norm;
                                norm_z = norm_z/length_norm;
                                lamb = objects[idx+6]*dot(norm_x, norm_y, norm_z, light_x, light_y, light_z)+objects[idx+7];
                            this.color(objects[idx + 2]*lamb, objects[idx + 3]*lamb, objects[idx + 4]*lamb);
                        }
                    }
                }
            }, opt);
            return y;
        }
        var start_time;
        var end_time;

        var mykernel = doit("gpu");
        start_time = Math.floor(new Date().getTime());
        mykernel(halfWidth,pixelWidth,halfHeight,pixelHeight,objects,camera,lights);
        var canvas = mykernel.getCanvas();
        document.getElementsByTagName('body')[0].appendChild(canvas);
        end_time = Math.floor(new Date().getTime());
        document.write(end_time - start_time);

        var f = document.querySelector("#fps");
        var angle = 0;
        var rotRad = objects[23]-objects[10];
        function renderLoop() {
            if (selection === 1)
            {
                camera[2]+=10;
                selection = 0;
            }
            else if(selection === 2)
            {
                camera[2]-=10;
                selection = 0;
            }
            f.innerHTML = fps.getFPS();
            mykernel(halfWidth, pixelWidth, halfHeight, pixelHeight, objects, camera, lights);
            var cv = document.getElementsByTagName("canvas")[0];
            var bdy = cv.parentNode;
            var newCanvas = mykernel.getCanvas();
            bdy.replaceChild(newCanvas, cv);
            objects[23] = objects[10]+Math.cos(angle)*rotRad;
            objects[25] = objects[12]+Math.sin(angle)*rotRad;
            objects[50] = objects[10]+Math.cos(-angle)*rotRad;
            objects[52] = objects[12]+Math.sin(-angle)*rotRad;
            angle = angle+0.01;
            requestAnimationFrame(renderLoop);
        }
        window.onload = renderLoop;
    </script>
    <canvas width="800" height="600"></canvas>
</body>
</html>